# -*- coding: utf-8 -*-
"""bis lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vg54u8TXCGhU-yMtdeWk6HpzPzjeXiGv
"""

import random
import math
import numpy as np

# Constants
NUM_ANTS = 10
NUM_ITERATIONS = 100
ALPHA = 1.0  # Influence of pheromone
BETA = 2.0   # Influence of heuristic information (e.g., energy or distance)
RO = 0.1     # Pheromone evaporation rate
Q = 1.0      # Total pheromone deposited by each ant
DIST_THRESHOLD = 5.0  # Example: minimum distance threshold for communication
ENERGY_COST_FACTOR = 0.5  # Factor to control the energy cost influence

# Nodes in the network (example positions in 2D)
nodes = [(1, 1), (2, 3), (4, 5), (7, 8), (10, 10)]
sink = (12, 12)  # Central Station (Sink)

# Function to calculate the Euclidean distance between two points
def euclidean_distance(node1, node2):
    return math.sqrt((node1[0] - node2[0])**2 + (node1[1] - node2[1])**2)

# Function to calculate energy consumption between two nodes based on distance
def energy_consumption(distance):
    # Simple model: Energy consumed is proportional to distance
    return distance * ENERGY_COST_FACTOR

# Heuristic for the problem (Energy cost or distance to sink)
def heuristic(node, sink):
    return 1 / (1 + euclidean_distance(node, sink))

# Initialization of pheromone matrix
def initialize_pheromones(num_nodes):
    pheromones = np.ones((num_nodes, num_nodes))  # Initial pheromone levels
    np.fill_diagonal(pheromones, 0)  # No self-loop
    return pheromones

# Function to select the next node based on pheromone and heuristic information
def select_next_node(current_node, pheromones, visited, alpha, beta):
    prob = []
    for i in range(len(pheromones)):
        if i != current_node and i not in visited:
            pheromone_value = pheromones[current_node][i] ** alpha
            heuristic_value = heuristic(nodes[current_node], nodes[i]) ** beta
            prob.append(pheromone_value * heuristic_value)
        else:
            prob.append(0)

    total_prob = sum(prob)
    prob = [p / total_prob if total_prob > 0 else 0 for p in prob]

    # Choose the next node based on probability distribution
    next_node = random.choices(range(len(pheromones)), prob)[0]
    return next_node

# Function to simulate the ants' behavior
def ant_colony_algorithm(nodes, sink, num_ants, num_iterations, alpha, beta, rho, q):
    num_nodes = len(nodes)
    pheromones = initialize_pheromones(num_nodes)

    best_path = None
    best_cost = float('inf')

    for _ in range(num_iterations):
        all_paths = []
        all_costs = []

        # Each ant constructs a path
        for _ in range(num_ants):
            visited = [random.randint(0, num_nodes - 1)]  # Random starting node
            path = visited[:]
            total_cost = 0

            # Construct the path for the ant
            while len(path) < num_nodes:
                current_node = path[-1]
                next_node = select_next_node(current_node, pheromones, visited, alpha, beta)
                path.append(next_node)
                total_cost += energy_consumption(euclidean_distance(nodes[current_node], nodes[next_node]))

            # Add cost to sink
            last_node = path[-1]
            total_cost += energy_consumption(euclidean_distance(nodes[last_node], sink))

            all_paths.append(path)
            all_costs.append(total_cost)

            if total_cost < best_cost:
                best_cost = total_cost
                best_path = path

        # Update pheromones based on the paths found by ants
        pheromones = (1 - rho) * pheromones  # Evaporate pheromones

        for i in range(num_ants):
            for j in range(len(all_paths[i]) - 1):
                pheromones[all_paths[i][j]][all_paths[i][j + 1]] += q / all_costs[i]

    return best_path, best_cost

# Main function to run the ACO
def main():
    # Run Ant Colony Optimization
    best_path, best_cost = ant_colony_algorithm(nodes, sink, NUM_ANTS, NUM_ITERATIONS, ALPHA, BETA, RO, Q)

    print("Best Path Found:", best_path)
    print("Minimum Energy Consumption:", best_cost)

if __name__ == "__main__":
    main()

import random
import math
import numpy as np

# Constants
NUM_ANTS = 10                # Number of ants
NUM_ITERATIONS = 10          # Number of iterations (changed to 10)
ALPHA = 1.0                  # Influence of pheromone
BETA = 2.0                   # Influence of heuristic (distance-based)
RO = 0.1                     # Pheromone evaporation rate
Q = 1.0                      # Total pheromone deposited by each ant

# Example: Coordinates of cities (TSP problem)
cities = [(0, 0), (1, 3), (4, 3), (6, 1), (3, 2)]  # (x, y) coordinates of cities

# Function to calculate the Euclidean distance between two cities
def euclidean_distance(city1, city2):
    return math.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)

# Initialize the pheromone matrix
def initialize_pheromones(num_cities):
    pheromones = np.ones((num_cities, num_cities))  # Start with equal pheromone levels
    np.fill_diagonal(pheromones, 0)  # No self-loop (no travel from a city to itself)
    return pheromones

# Heuristic function: In this case, the inverse of the distance between two cities
def heuristic(city1, city2):
    return 1 / (1 + euclidean_distance(city1, city2))

# Function to select the next city based on pheromone and heuristic information
def select_next_city(current_city, pheromones, visited, alpha, beta):
    prob = []
    for i in range(len(pheromones)):
        if i not in visited:
            pheromone_value = pheromones[current_city][i] ** alpha
            heuristic_value = heuristic(cities[current_city], cities[i]) ** beta
            prob.append(pheromone_value * heuristic_value)
        else:
            prob.append(0)

    # Normalize the probabilities
    total_prob = sum(prob)
    if total_prob > 0:
        prob = [p / total_prob for p in prob]
    else:
        prob = [0] * len(prob)

    # Select the next city based on the probability distribution
    next_city = random.choices(range(len(pheromones)), prob)[0]
    return next_city

# Function to simulate the ants' behavior
def ant_colony_algorithm(cities, num_ants, num_iterations, alpha, beta, rho, q):
    num_cities = len(cities)
    pheromones = initialize_pheromones(num_cities)

    best_path = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        all_paths = []
        all_costs = []

        # Each ant constructs a path
        for _ in range(num_ants):
            visited = [random.randint(0, num_cities - 1)]  # Random starting city
            path = visited[:]
            total_cost = 0

            # Construct the path for the ant
            while len(path) < num_cities:
                current_city = path[-1]
                next_city = select_next_city(current_city, pheromones, visited, alpha, beta)
                path.append(next_city)
                total_cost += euclidean_distance(cities[current_city], cities[next_city])

            # Add the cost to return to the starting city (closed loop)
            total_cost += euclidean_distance(cities[path[-1]], cities[path[0]])

            all_paths.append(path)
            all_costs.append(total_cost)

            # Update the best solution found so far
            if total_cost < best_cost:
                best_cost = total_cost
                best_path = path

        # Update pheromones based on the paths found by ants
        pheromones = (1 - rho) * pheromones  # Pheromone evaporation

        for i in range(num_ants):
            for j in range(len(all_paths[i]) - 1):
                pheromones[all_paths[i][j]][all_paths[i][j + 1]] += q / all_costs[i]
            # Update pheromone for the return to the starting city
            pheromones[all_paths[i][-1]][all_paths[i][0]] += q / all_costs[i]

        # Optional: Print iteration results
        print(f"Iteration {iteration + 1}/{num_iterations}, Best Cost: {best_cost}")

    return best_path, best_cost

# Main function to run the ACO
def main():
    best_path, best_cost = ant_colony_algorithm(cities, NUM_ANTS, NUM_ITERATIONS, ALPHA, BETA, RO, Q)

    print("\nBest Path Found:", best_path)
    print("Minimum Path Length (Cost):", best_cost)
    print("City Order:", [cities[i] for i in best_path])

if __name__ == "__main__":
    main()